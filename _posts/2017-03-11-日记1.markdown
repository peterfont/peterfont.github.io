---
layout: post
title:  "日记"
date:  2017-03-11 15:06:27
categories: jekyll update
tag:
  - jekyll-feed
  - 测试
---
Jasmine 测试框架

#### 介绍

jasmine是一个行为驱动的javascript代码测试框架。不依赖任何其他的第三方js库。不需要DOM。有非常清晰易用的。

version 2.5.2

##### 内容

1. Suites: 测试套件(测试组)，可以包含多个Specs。

```javascript
    /*
        global
        name string 描述
        func function 方法
    */
    describe("name",func);
    
```
2.Specs ：测试规格（测试单元）
  
  可以包含一个或者多个表达式测试语句。一个exprectation就是一个断言
  assertion，返回true 或 false。
  所有的表达式都通过，这个测试规格才通过。

```javascript
    /*
     global
     name string 描述
     func function 方法
    */
    it("name",func)
    
    
```
3. Expecations 表达式

```jacascript
    /**
        value 需要测试的值
        value2 预期的值
        需要链式调用匹配器和预期的值进行比较,expect.not则相反
    */
    expect(value).matchers(value2)
    expect(value).not.mathchers(value)
    
    
```

4. Matchers匹配器,Jasmine自带的匹配器
    - toBe
    - eoEqual
    - toMatch
    - toBeDefined
    - toBeUndefined
    - toBeNull
    - toBeTruthy
    - toBeFalsy
    - toContain
    - toBeLessThan
    - toBeCloseTo
    - toThrow
    - toThrowError

4.1. 可以调用方法fail，使测试用例失败.
```
describe("A spec using the fail function", function() {
  var foo = function(x, callBack) {
    if (x) {
      callBack();
    }
  };

  //如果fail()方法被调用，测试不会通过
  it("should not call the callBack", function() {
    foo(false, function() {
      fail("Callback has been called");
    });
  });
});

```

-----------

用describe分组相关的测试用例
describe的描述回合it的描述成一个测试的完整名字。如果你命名很好的，这个名字就是一个BDD风格的miao'shu描述。

---------

##### 启动和卸载（Setup and Teardown）

为了适合DRY(dont repeat yourself) 避免多次初始化和卸载。Jasmine提供
beforeEach,aferEach,beforeAll and afterAlld方法

1. beforeEach describe中的每一个it被调用前都会执行这个方法。

2. afterEach describe中的每一个it被调用后都执行这个方法。
```
describe("A spec using beforeEach and afterEach", function() {
  var foo = 0;

  beforeEach(function() {
    foo += 1;
  });

  afterEach(function() {
    foo = 0;
  });

  it("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });

  it("can have more than one expectation", function() {
    expect(foo).toEqual(1);
    expect(true).toEqual(true);
  });
});

```
3. beforeAll describe中开始时只被调用一次

4. afterAll
describe中结束时被调用一次
```
describe("A spec using beforeAll and afterAll", function() {
  var foo;

  beforeAll(function() {
    foo = 1;
  });

  afterAll(function() {
    foo = 0;
  });

  it("sets the initial value of foo before specs run", function() {
    expect(foo).toEqual(1);
    foo += 1;
  });

  it("does not reset foo between specs", function() {
    expect(foo).toEqual(2);
  });
});
```
-------------

##### this关键字

beforeEach/it/afterEach中的this都是同共享一个空object。下一组beforeEach/it/afterEach共享一个空object

```
describe("A spec", function() {
  beforeEach(function() {
    this.foo = 0;
  });

  it("can use the `this` to share state", function() {
    expect(this.foo).toEqual(0);
    this.bar = "test pollution?";
  });

  it("prevents test pollution by having an empty `this` created for the next spec", function() {
    expect(this.foo).toEqual(0);
    expect(this.bar).toBe(undefined);
  });
});
```

##### describe块嵌套

describe允许嵌套，it可以定义在任何嵌套位置。这就是允许测试套件组成一个方法树。每一个it执行前，Jamine会顺序执行每一个beforeEach，并在结束的时候按照相同的顺序执行afterEach。

```
describe("A spec", function() {
  var foo;

  beforeEach(function() {
    foo = 0;
    foo += 1;
  });

  afterEach(function() {
    foo = 0;
  });

  it("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });

  it("can have more than one expectation", function() {
    expect(foo).toEqual(1);
    expect(true).toEqual(true);
  });

  describe("nested inside a second describe", function() {
    var bar;

    beforeEach(function() {
      bar = 1;
    });

    it("can reference both scopes as needed", function() {
      expect(foo).toEqual(bar);
    });
  });
});
```

-----------------

##### 禁用测试套件 Suites

可以用xdescribe方法禁用测试，里面的所有测试单元都会被跳过。运行时他们的状态是pending。

```
xdescribe("A spec", function() {
  var foo;

  beforeEach(function() {
    foo = 0;
    foo += 1;
  });

  it("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });
});

```
##### pending Specs

pending Specs（测试规格）不会被运行，展示的结果是pending。可以用xit标记为pending状态。

默认的没有function的测试规格都是pending的，it(name).

可以直接调用pending，在控制台上显示信息。


```
xit("can be declared 'xit'", function() {
    expect(true).toBe(false);
  });
  it("can be declared with 'it' but without a function");
  it("can be declared by calling 'pending' in the spec body", function() {
    expect(true).toBe(false);
    pending('this is why it is pending');
  });
});

```

------


